# GodotTestGame
## Описание
Игра, в которой вам играя за космонавта необходимо собрать 20 монет для победы, избегая при этом врагов (летучих мышей)
## Управление
A,D - бег влево или вправо
Пробел, W -прыжок. Второе нажатие в воздухе активирует двойной прыжок
Shift - Использование реактивного ранца

# Ответы На вопросы

## Как работает система сцены в Godot и в чем ее преимущества? Приведите блок схему простенького платформера на Godot, где есть:
### Стартовый экран загрузки с текстом
### Экран меню
### Игровой экран с персонажем и противником
Система сцены в годот построена на иерархии различных узлов Nodes. Сцена - самодостаточный многократно используемы набор узлов. Каждая сцена может быть добавлена (инстанцирована) в другую сцену как один отдельный узел. Это позволяет осуществить Модульность программы (сцены и новые ноды собираются из уже существующих нод, что позволяет делать их очень гибкими) и повторное использование сцен (сцену можно загрузить и повторно использовать в любой момент программы)
Блок схема:
#### StartScreen.tscn (Control)  
- Label (текст "Загрузка...")  
После загрузки идет смена сцены:
```gdscript
get_tree().change_scene_to_file("Menu.tscn")
```
#### Menu.tscn (Control)
- Label (Название Игры)
- PlayButton (Кнопка играть)

При нажатии на кнопку Play идет смена сцены
```gdscript
get_tree().change_scene_to_file("MainScene.tscn")
```
#### MainScene.tscn
- Player (объект класса Player, игрок, существует в файловой системе как Player.tscn)
- Enemy (класс врага, также инстанцирован из файла Enemy.tscn)
## Объясните, как работают сигналы (Signals) в Godot? Приведите общий пример использования сигналов и\или двух несвязанных между собой node (Не имеющие общего родителя)
Сигналы - механизм обмена данными в Godot. Позволяет коду быть слабо связным. Работает следующим образом: существует объект-эмиттер, он передает сигнал, существуют также Подписчики, принимающие сигнал, для толго чтобы объект стал приемником сигнала его надо подписать на сигнал эмиттера через например connect("имя сигнала", Callable(self, "имя метода")). Например есть враг, который является эмиттером сигнала "cause_damage" и игрок, который является подписчиком этого сигнала. При атаке враг эмитирует этот сигнал, а принимает его игрок, приняв сигнал игрок сам знает что ему нужно вызвать метод "take_damage" и получить урон. Слабо связным код становится по той причине, что враг не знает какой метод вызвать в классе игрока и какие параметры ему нужно изменять.

Враг:
```gdscript
signal cause_damage(damage)
func Atack():
    emit cause_damage(10)
```
Игрок:

```gdscript
enemy.connect("cause_damage", Callable(self, "Take_damage"))

func Take_Damage(damage):
    self.health -= damage
```

## Как в GDScript организовать наследование, и зачем это нужно?
Наследование в GDScript организуется в коде через extends. Оно позволяет наследовать поля и методы иных классов. Например если в главном скрипте игрока Player.gd есть extend CharacterBody2D, то игрок будет наследовать все поля и методы класса ChatacterBody2D. Наследование позволяет реализовать в коде полиморфизм и реюзабельность кода. Например для гоблинов, эльфов и гномов можно создать общий класс врагов Creature, написать в нем все общие функции и переменные, а дальше наследовать от него иные классы через extends Enemy

## Как работает система импорта ресурсов в Godot? Что произойдет, если изменить исходный файл изображения?
При импорте ресурсов Godot создает отдельный файл .import хранящий параметры импорта ресурса. При импорте godot создает новый объект в .godot/imported представляющий собой более оптимизированный для движка ресурс (для тех типов данных, для которых возможно). Пользователь волен изменять параметры импорта в самом движке и переимпортировать ресурс. Система также сама отслеживает изменения в импортируемом ресурсе, потому если например изменить изображение, то godot это отследит и реимпортирует ресурс.

## Что такое _process() и _physics_process() в GDScript и чем они отличаются?
Основные методы узлов в Godot. Они выполняются во время активности игры и в них происходит вся основная логика объектов.  Отличие в том, как выполняется _process(delta) и _physics_process(delta), _process() вызывается каждый кадр и его выполнение напрямую зависит от FPS пользователя, а _physics_process() выполняются каждый фиксированный промежуток времени, каждый тик. _physic_process используется для обработки физики объекта, а _process() для визуализации

## Как создать и использовать таймер (Timer) в Godot?
Таймер это особый тип узла. Создается он также как и любой иной узел либо вручную либо через скрипт.
Таймер имеет несколько полей:
Wait_time - поле отвечающее за время ожидания таймера, которое он будет неактивен
One_shot - если true то после истечения времени таймер сработает один раз, иначе будет повторяться постоянно
Autostart - запуск таймера сразу после его создания
Использование таймера проще всего осуществляется через его сигналы. По истечении времени таймер вызовет сигнал timeout(), а все подписанные на него объекты вызовут необходимый метод
Пример инициализации таймера посредством скрипта. Пускай у нас есть объект, которому необходим таймер на 2 секунды, не повторяющийся и запускающийся при создании.
```gdscript
var Timer = Timer.new()
Timer.wait_time = 2.0
Timer.one_shot = true
Timer.autostart = true
self.add_child(Timer)
Timer.connect("timeout", Callable(self, "_on_timer_timeout"))

func _on_timer_timeout():
    print("сработал таймер")
```

## Объясните, как работает система слоев и масок (Layers and Masks) для коллизий в Godot.
Слои и маски определяют то, каким образом различные объекты будут взаимодействовать между собой при физическом взаимодействии. Параметр Layers объекта определяет то, на каком слое он находится сам, а слой Masks определяет то, с объектами на каких слоях может взаимодейтсвовать объект. Например у нас есть три слоя: Players(1), Enemies(2), Walls(3). узел Player имеет слой Players, узел Enemy имеет слой Enemies, при этом в масках у Players будет Enemies и Walls, чтобы корректно обрабатывать столкновения со стенами и удары врагов, а Enemy же будет иметь в масках Players и Walls. Также стоит отметить, что слои и маски битовые и в движке их может быть 32 штуки

## Как в GDScript организовать взаимодействие между разными сценами или узлами?
Взаимодействие в GDScript между разными сценами и узлами может быть осуществлено многими способами. Можно связать несколько узлов с помощью сигналов. Для обмена глобальными данными лучше всего использовать глобальные скрипты (singletones), автозагружаемые при выполнении. Например очки, в глобальном скрипте GlobalScript.gd объявляем 
```gdscript
var scores = 0
```
 и в любом узле их можно использовать, например увелчивать: 
```gdscript
GlobalScript.scores += 1.
```
Взаимодействие можно осуществлять через группы (add_to_group(), get_nodes_in_group(), get_tree().call_group())
Также взаимодействие может быть организовано и обыкновенной ссылкой на узел. var node = $Node2d как пример. Позволяет использовать все поля и методы объекта.

## Как загрузить и инстанцировать сцену динамически во время выполнения игры?
Загрузка, инстанциирование и добавление объекта к родителю. Например для врага
1) Загрузить через var enemy = load("res://enemy.tscn") (динамическая загрузка сцены) или var enemy = preload("res:://enemy.tscn) (предзагрузка при запуске скрипта) сохраненную сцену
2) Инстанциировать объект через var new_enemy = enemy.instantiate()
3) Добавить в дерево: get_tree().add_child(new_enemy)

## Какие средства профилирования и отладки предоставляет Godot? Как ими пользоваться?
1) Вывод. Во время выполнения игры можно выводить в консоль различные сообщения, позволяющие отследить корректность выполнения определенных методов
2) Ошибки. Туда выводится вся информация о предупреждениях и ошибках, возникающих во время выполнения программы.
3) Точки останова. Во время выполнения программы при достижении программой точки останова она останавливается и позволяет просмотреть значение всех локальных и глобальных переменных
4) Профайлер/ Визуальный профайлер. Позволяет отслеживать сколько времени и ресурсов занимает каждая функция в игре.
5) Мониторинг/ видеопамять показывают пользователю количество ресурсов, которые игра задействует на компьютере.
6) Удаленный отладчик. Позволяет подключиться к процессу игры локально или с другого устройства. Нужно для отладки игр на телефонах или консолях.
## Как реализовать систему сохранения и загрузки данных игры в Godot? Какие существуют подходы и какие классы для этого используются?
Система сохранения и загрузки данных может быть реализована через
1) JSON файлы. Godot имеет встроенные инструменты для записи, чтения и парсинга JSON фалйов. Доступ к файлу осуществляется через FileAccess а парсинг JSON происходит соответсвенно через JSON
2) Сохранение настроек может быть осуществлено через конфиг-файлы. В godot для этого задействуется специальный класс ConfigFile.
3) Более высокоуровневый способ сохранения данных - использование ResourceSaver и ResourceLoader
## Как подключить и использовать Android плагины в Godot? Какие шаги необходимы для интеграции?
Андроид плагины поставляются в godot в виде андроид библиотек .aar. Имеющийся андроид плагин необходимо поместить в папку res://android/plugins. После чего плагин необходимо активировать в Project Settings -> Plugins. Затем Export выбираем Android export preset. Код Java/Kotlin в godot регистрируется как singletone, соответственно для взаимодействия с плагином используем:
```gdscript
if Engine.has_singleton("MyPlugin"):
		var singleton = Engine.get_singleton("MyPlugin")
		print(singleton.myPluginFunction("World"))
```